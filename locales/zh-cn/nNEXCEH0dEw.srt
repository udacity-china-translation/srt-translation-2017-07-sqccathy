1
00:00:00,000 --> 00:00:03,000
我认为选项四是最佳答案

2
00:00:03,000 --> 00:00:05,000
选项二也很不错

3
00:00:05,000 --> 00:00:07,000
但我认为选项四更好些

4
00:00:07,000 --> 00:00:10,000
选项一和三都太麻烦了

5
00:00:10,000 --> 00:00:15,000
那么我们来看看 为什么四是最佳选择

6
00:00:15,000 --> 00:00:20,000
首先缩小这些选项 为我的图解省点空间

7
00:00:20,000 --> 00:00:22,000
这就是选项一

8
00:00:22,000 --> 00:00:25,000
我们有一个列表

9
00:00:25,000 --> 00:00:28,000
列表的元素就是 关键词

10
00:00:28,000 --> 00:00:34,000
每个关键词都是一个字符串  
关键词后面则是出现该关键词的 URL

11
00:00:34,000 --> 00:00:38,000
所以 选项一里 我们有一个列表 这个列表包含了字符串

12
00:00:38,000 --> 00:00:41,000
每个字符串不是关键词就是 URL

13
00:00:41,000 --> 00:00:45,000
同时还有一个关键词 后面跟着出现该关键词的 URL

14
00:00:45,000 --> 00:00:47,000
看上去既美观又简单

15
00:00:47,000 --> 00:00:49,000
只有一个列表而已

16
00:00:49,000 --> 00:00:51,000
但是这里有两个大麻烦

17
00:00:51,000 --> 00:00:54,000
第一个麻烦是 很难区分关键词和 URL

18
00:00:54,000 --> 00:00:58,000
比如我们可以说 任何以 HTTP 开头的字符串都是 URL

19
00:00:58,000 --> 00:01:01,000
我们的 URL 都是格式化后的链接

20
00:01:01,000 --> 00:01:04,000
任何不以 HTTP 开头的都是关键词

21
00:01:04,000 --> 00:01:06,000
但也可能关键词的开头就是 HTTP

22
00:01:06,000 --> 00:01:09,000
这么一来 就无法进行区分了

23
00:01:09,000 --> 00:01:11,000
这种表达法的另一个大麻烦就是

24
00:01:11,000 --> 00:01:14,000
关键词的循环遍历非常困难

25
00:01:14,000 --> 00:01:18,000
如果从关键词一开始找下一个关键词

26
00:01:18,000 --> 00:01:20,000
从哪个位置开始寻找无从知晓

27
00:01:20,000 --> 00:01:23,000
每个关键词可能都有不同的链接数

28
00:01:23,000 --> 00:01:24,000
我们不得不对每个元素进行搜索

29
00:01:24,000 --> 00:01:28,000
来判断下一个出现的究竟是 URL 还是下一个关键词

30
00:01:28,000 --> 00:01:31,000
这种办法行不通

31
00:01:31,000 --> 00:01:34,000
所以选项一显然并非良策

32
00:01:34,000 --> 00:01:36,000
再来看看选项三

33
00:01:36,000 --> 00:01:39,000
这个我也说过 非常麻烦

34
00:01:39,000 --> 00:01:42,000
选项三包括一个列表

35
00:01:42,000 --> 00:01:45,000
列表中的每个元素本身又是一个列表

36
00:01:45,000 --> 00:01:48,000
而元素列表这种列表的第一元素是一个 URL

37
00:01:48,000 --> 00:01:51,000
第二元素是关键词列表

38
00:01:51,000 --> 00:01:55,000
URL 中可能会出现的关键词列表

39
00:01:55,000 --> 00:01:59,000
这个选项比选项一结构繁复

40
00:01:59,000 --> 00:02:01,000
我们可以区分 URL 在哪

41
00:02:01,000 --> 00:02:04,000
因为所有 URL 都是列表的第一个元素

42
00:02:04,000 --> 00:02:08,000
我们也能区分关键词在哪 因为它们都在列表的第二个元素里

43
00:02:08,000 --> 00:02:12,000
这个选项的问题是 我们很难

44
00:02:12,000 --> 00:02:15,000
搜索关键词出现的页面

45
00:02:15,000 --> 00:02:18,000
要搜索关键词几乎等于重新扫描所有页面

46
00:02:18,000 --> 00:02:21,000
如果要搜索特定关键词 我们要搜索每个元素

47
00:02:21,000 --> 00:02:24,000
再搜索元素的第二部分

48
00:02:24,000 --> 00:02:25,000
对之进行扫描 确定关键词是否出现

49
00:02:25,000 --> 00:02:28,000
如果出现了 那么这个 URL 要包含在搜索结果里

50
00:02:28,000 --> 00:02:32,000
如果没有出现 则不出现在搜索结果里

51
00:02:32,000 --> 00:02:35,000
但找到特定关键词就要搜索每一个元素

52
00:02:35,000 --> 00:02:38,000
和该元素的所有关键词

53
00:02:38,000 --> 00:02:41,000
所以这个选项也行不通

54
00:02:41,000 --> 00:02:45,000
因为我们建立索引的初衷就是实现快速搜索

55
00:02:45,000 --> 00:02:48,000
无需浏览这些页面的所有内容

56
00:02:48,000 --> 00:02:51,000
可这个表达法不能解决这一需求

57
00:02:51,000 --> 00:02:53,000
现在 只剩两个选项了

58
00:02:53,000 --> 00:02:56,000
我说过 这两个选项都可行

59
00:02:56,000 --> 00:02:59,000
但我认为选项四是最佳答案

60
00:02:59,000 --> 00:03:01,000
我们来看看原因

61
00:03:01,000 --> 00:03:03,000
先看选项二

62
00:03:03,000 --> 00:03:06,000
这是一个列表 列表中的每个元素都是一个列表

63
00:03:06,000 --> 00:03:09,000
元素列表自身是包含了关键词的列表

64
00:03:09,000 --> 00:03:14,000
关键词后面是出现该关键词的URL

65
00:03:14,000 --> 00:03:18,000
与前两个选项相较 该选项有个很大的优势

66
00:03:18,000 --> 00:03:21,000
即它意味着区分关键词和 URL 更加容易

67
00:03:21,000 --> 00:03:24,000
因为关键词始终是列表的第一个元素

68
00:03:24,000 --> 00:03:29,000
且与之前选项不同 该选项要浏览关键词很容易

69
00:03:29,000 --> 00:03:32,000
对于所有包含关键词的列表而言 我们只需检索第一元素

70
00:03:32,000 --> 00:03:34,000
来确认这是否是我们搜寻的关键词

71
00:03:34,000 --> 00:03:36,000
如果不是 我们就继续搜索

72
00:03:36,000 --> 00:03:39,000
我们不需要浏览所有网页上的全部内容

73
00:03:39,000 --> 00:03:43,000
只需浏览列表的第一个元素 来找出关键词

74
00:03:43,000 --> 00:03:45,000
所以 这个选项可行

75
00:03:45,000 --> 00:03:48,000
我认为选项四更好的原因

76
00:03:48,000 --> 00:03:51,000
则是它对关键词和 URL 进行了更好的区分

77
00:03:51,000 --> 00:03:54,000
与选项二相比 选项四的不同之处在于

78
00:03:54,000 --> 00:03:57,000
其内部列表不是简单列表

79
00:03:57,000 --> 00:04:00,000
而是跟着 URL 的关键词

80
00:04:00,000 --> 00:04:03,000
内部列表只包含了两个元素

81
00:04:03,000 --> 00:04:08,000
即关键词 和一列 URL

82
00:04:08,000 --> 00:04:12,000
这里有另外一个列表 即一列 URL

83
00:04:12,000 --> 00:04:14,000
这就是选项四

84
00:04:14,000 --> 00:04:17,000
主列表中的每个元素都是一个列表

85
00:04:17,000 --> 00:04:19,000
列表只包含两个元素

86
00:04:19,000 --> 00:04:22,000
即关键词 - 比如这里的 “udacity”

87
00:04:22,000 --> 00:04:26,000
及其后出现关键词的所有 URL 的列表

88
00:04:26,000 --> 00:04:29,000
比选项二相比我更喜欢这个选项的原因

89
00:04:29,000 --> 00:04:34,000
是它对关键词和 URL 列表作出了非常清晰的区分

90
00:04:34,000 --> 00:04:38,000
也就是说 如果我们想对另一些内容

91
00:04:38,000 --> 00:04:42,000
如每个关键词的搜索次数保持跟踪

92
00:04:42,000 --> 00:04:44,000
操作会很简便

93
00:04:44,000 --> 00:04:49,000
这里可以加一个额外元素 来对搜索次数进行跟踪

94
00:04:49,000 --> 00:04:52,000
选项二对此如何操作并不明确

95
00:04:52,000 --> 00:04:58,000
也许可以在这里再加个值 在这儿加个数字

96
00:04:58,000 --> 00:05:00,000
我们可能需要对很多已经写好的代码进行修改

97
00:05:00,000 --> 00:05:03,000
现在不是从第一个位置开始搜索 URL

98
00:05:03,000 --> 00:05:06,000
而是要从第二个位置位置开始了

99
00:05:06,000 --> 00:05:09,000
或者我们可以将数字加在最后 来避免这一问题

100
00:05:09,000 --> 00:05:13,000
但这么一来 我们又得找到这个数字的位置

101
00:05:13,000 --> 00:05:15,000
有简单的方法来找出列表的最后一个元素

102
00:05:15,000 --> 00:05:18,000
但这会使工作更加复杂

103
00:05:18,000 --> 00:05:20,000
而一旦开始插入越来越多的内容

104
00:05:20,000 --> 00:05:23,000
对全部内容进行跟踪就会非常困难

105
00:05:23,000 --> 00:05:24,000
选项四提供了更完备的结构

106
00:05:24,000 --> 00:05:28,000
通过将所有 URL 放进一个列表 我们可以将之视为一个列表

107
00:05:28,000 --> 00:05:31,000
这样就比将 URL 和关键词绑在一起简单得多了

108
00:05:31,000 --> 00:05:34,000
我们还可以往里面添加额外的元素

109
00:05:34,000 --> 00:05:37,000
如果我们希望对关键词搜索次数保持跟踪的话

110
00:05:37,000 --> 00:05:41,000
我们也可添加任何之后有助于我们的结构的其它信息

111
00:05:41,000 --> 00:05:44,000
以上就是选项四更优的原因

112
00:05:44,000 --> 00:05:49,000
在做软件时 最重要的任务之一就是决定数据结构

113
00:05:49,000 --> 00:05:51,000
选对了结果

114
00:05:51,000 --> 00:05:55,000
编写代码的工作变得易如反掌

115
00:05:55,000 --> 00:05:57,000
如果一开始选错了数据结构

116
00:05:57,000 --> 00:06:01,000
比如这里我们选了选项一或三

117
00:06:01,000 --> 00:06:03,000
编写代码则难如登天

118
00:06:03,000 --> 00:06:06,000
甚至有时 几乎无法再写出好的代码

119
00:06:06,000 --> 00:06:10,000
所以计算机科学最重要的任务之一 就是对数据结构进行思考

120
00:06:10,000 --> 00:06:12,000
本课程中我们还将接触更多

121
00:06:12,000 --> 00:06:16,000
接下来的课程里 会有专门针对这一问题的内容

122
00:06:16,000 --> 00:06:19,000
会着重介绍如何更好地设计和运用数据

